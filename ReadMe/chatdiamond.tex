\documentclass{article}
\usepackage{listings}             % Include the listings-package
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{csquotes}
\usepackage{changelog}
\usepackage{tabularx}
\usepackage{mathtools}
\usepackage{mdframed}
\usepackage{array}
\usepackage{float}
\usepackage{tikz}
\usepackage{soul}
\usepackage{makecell}
\usepackage{makeidx}
\usepackage{forest}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\newcommand{\ChatDiamondVersion}{0.1.0-alpha}
\newcommand{\FileColor}[1]{{\color{Purple} #1}}
\newcommand{\FolderColor}[1]{{\color{mygray} #1}}

\lstdefinelanguage{cmake} {morekeywords={one,two,three,four,five,six,seven,eight,
nine,ten,eleven,twelve,o,clock,rock,around,the,tonight}, sensitive=false,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]", }

% Container for tabularx
\floatstyle{plain}
\newfloat{tabcontainer}{thp}{lop}
\floatname{tabcontainer}{Table}

% Container for tikz flow-charts
\floatstyle{plain}
\newfloat{fccontainer}{thp}{lop}
\floatname{fccontainer}{FlowChart}

% For visual representation of Flow-Charts
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
    
\title{Chat Diamond}
\author{The\_Cowboy}
\pagestyle{headings}

\begin{document}

\maketitle
\tableofcontents

\lstset{language=Java}          % Set your language (you can change the language for each code-block optionally)

\section{Introduction}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or    %\usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, %does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code %(possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, %right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within %not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it %overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be %numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also %try caption instead of title
} %optionally)

Chat Diamond (version \ChatDiamondVersion) is a purely client-side mod for Unreal Tournament G.O.T.Y (UT99) which relplaces the default UT console with a more appropriate one.  This functionality allows the achievement of the following
\begin{itemize}
\item Gathering of raw messages delivered to the console and relevant categorization, along with chat message seperation, of them.
\item Introduction of appropriate web-query for translation to local or demand of the language.
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{img}
\caption{Chat Diamond \ChatDiamondVersion~Chat.}
\label{fig:chatdiamond}
\end{figure}

\subsection{Chat Window}
Figure \ref{fig:chatdiamond} shows the current form of the chat window. The following features are supported
\begin{itemize}
\item Display of sender's avatar face.
\item Static emojis and animated emotes.
\item Display of Date and Time (long format for now).
\item Display of the Server name for reference purposes.
\item Ability to copy text and IP address (both game and web server) from chat messages.
\begin{itemize}
\item IPs of the format xxx.xxx.xxx.xxx are considered web server IPs.
\item IPs of the format xxx.xxx.xxx.xxx:xxxx are considered game server IPs.
\end{itemize}
\item Ability to display hyperlinks with clickable feature for relevant navigation and mouse cursor distinction.
\begin{itemize}
\item On clicking web or game server IP, the player can reach the relevant website (http:// only) or UT99 game server.
\item On clicking http:://something.com or https://something.com, the player can reach the desired site, if valid url is posted.
\end{itemize}
\end{itemize}

\subsection{Emoji Window}

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{img_emos}
\caption{Chat Diamond \ChatDiamondVersion~Emojis.}
\label{fig:chatdiamond_emos}
\end{figure}

In order to display complete list of supported emojis (and emotes), collectively called \emph{Emos}, the Emoji window \ref{fig:chatdiamond_emos} has been 
generated by code (which was texture based for UTChat).  This allows the support for the following 
\begin{itemize}
\item A curation of selection page for framed Emos.
\item An interactive way of display, which depresses the frame being hovered with a sound and generated a distinct clicking
experience.
\item Emoji and Chat window text areas are synced, meaning, whatever you write or select in one window, which gets registered
in the text are, is copied over to the next one.
\item My personal favorite, the scrolling capability.
\end{itemize}


\subsection{Console Window}

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{img_console}
\caption{Chat Diamond \ChatDiamondVersion~Console.}
\label{fig:chatdiamond_console}
\end{figure}

The console now has the following features
\begin{itemize}
\item Non-chat filter to filter out server or mutator advertisements, in the console. Although SmartCTF cover and seal messages may also get filtered.
\item Event filter censors death messages corresponding to the weapon used.
\item A clear button to clean or reset the console.
\item A working status bar linked with console configuration modifiers.
\end{itemize}

\subsection{More Pages}
Please keep in mind that this is very initial stage of Chat Diamond (\ChatDiamondVersion).  The pages to configure various properties of chat messages
and date format shall be made available as we progress with the development cycle.

\section{Installation}
Chat Diamond is developed and tested with UT99, 469c client.  Although the mod should work on previous versions, I take no pains for maintaining that code simply because I feel that we all should work towards pushing forward the community effort in driving the game (and UE 1) towards modern experience.  So by not supporting the code for earlier versions I am supporting the later versions.

With that being written, feel free to send pull requests to \href{https://github.com/ravimohan1991/ChatDiamond/}{Chat Diamond} repository, even for ealier game versions.

Chat Diamond is essentially a console (and not for the server).  So for installation do the following
\begin{itemize}
\item Place the \FileColor{ChatDiamond.dll} and \FileColor{ChatDiamond.u} files in \FolderColor{System} directory.
\item Open \FileColor{UnrealTournament.ini} and find the section \\

\fbox{%
    \parbox{\textwidth}{%
       [Engine.Engine]\\
       GameRenderDevice=VulkanDrv.VulkanRenderDevice\\
       AudioDevice=ALAudio.ALAudioSubsystem\\
        \ldots  \\       
       {\color{Green}Console=UTMenu.UTConsole}\\
       \ldots        
    }%
}
\\

\item Modify to \\

\fbox{%
    \parbox{\textwidth}{%
        \ldots  \\       
       {\color{Green}Console=ChatDiamond.CDUTConsole}\\
       \ldots        
    }%
}
\\

\item And that is it!  You can now summon console by usual `$\sim$' key.

\subsection{Configuration}
I am not providing {\color{purple}ChatDiamond.ini}, which should be generated after first successful run of the mod.  

Once that is done make sure to configure the file.

\end{itemize}

\section{A note on UT Messaging}
Chat Diamond's functionality is based upon the tenet ``A complete clientside user interface with no dependencies with the server''.  This would imply conforming to the UT standards and any server not conforming to the standards, if so, is not worth visiting.

Based upon the above motivation we have a choice to make between replacing the client HUD or UT console, in order to gather the UT messages clientside.  My first instinct was to replace the HUD because that would give more precise classification of the messages, in the sense Epic wrote the code, like \href{http://uncodex.ut-files.com/UT/v436/Source_botpack/challengehud.html}{so} (line 1499)

\begin{lstlisting}[frame=single]
// Entry point for string messages.
simulated function Message( PlayerReplicationInfo PRI, coerce string Msg, name MsgType )
{
    local int i;
    local Class<LocalMessage> MessageClass;

    switch (MsgType)
    {
        case 'Say':
        case 'TeamSay':
            MessageClass = class'SayMessagePlus';
            break;
        case 'CriticalEvent':
            MessageClass = class'CriticalStringPlus';
            LocalizedMessage( MessageClass, 0, None, None, None, Msg );
            return;
        case 'DeathMessage':
            MessageClass = class'RedSayMessagePlus';
            break;
        case 'Pickup':
            PickupTime = Level.TimeSeconds;
        default:
            MessageClass = class'StringMessagePlus';
            break;
     }
   %* \ldots *)           
\end{lstlisting}

The basic premise of many cheats providing aim assist is to modify the HUD clientside and display the adversary's position behind the wall or a radar.  This is the reason why modern anticheats are not receptive of clients modifying HUD, and thus, work with the concept of ``whitelisting''.

If the notion of ``cheat-anticheat'' interplay exists in the UT standards, then that simply doesn't fit with the tenant we began with.  We don't want to be sending request to server administrators for specifically whitelisting Chat Diamond which will be reverted by cold silent treatment to say the most and some naggy jibber jabber about the unknown-ness of Chat Diamond, especially when the mod is not that popular.

So with this thiking in mind, the better option would be to replace the client console, which I haven't seen any anticheat scanning. This not only gets the client out of hook for sending whitelisting requests but also provides a powerful mechanism to mould the console, specificifically for generic needs (see the concept of \emph{filters}).

\subsection{A minor PhD on console messages}

We start with the \href{http://uncodex.ut-files.com/UT/v436/Source_engine/playerpawn.html}{code} 

\begin{lstlisting}[frame=single]
event ClientMessage( coerce string S, optional Name Type, optional bool bBeep )
{
     %* \ldots *)    
    if (Player.Console != None)
        Player.Console.Message( PlayerReplicationInfo, S, Type );
    if (bBeep && bMessageBeep)
        PlayBeepSound();
    if ( myHUD != None )
        myHUD.Message( PlayerReplicationInfo, S, Type );
}       
\end{lstlisting}
and
\begin{lstlisting}[frame=single]
event TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep  )
{
    if (Player.Console != None)
        Player.Console.Message ( PRI, S, Type );
    if (bBeep && bMessageBeep)
        PlayBeepSound();
    if ( myHUD != None )
        myHUD.Message( PRI, S, Type );
}     
\end{lstlisting}

It is clear that both the console and HUD should receieve same messages with no discrimination (unless if coder specifically demands, as mentioned in \ref{foot:hudconsolediff}).  The console would display them, in what I would like to think, \emph{raw} form.  The \emph{diff}, between console and HUD, is shown in the figure \ref{fig:chatdiamond_console_hud}

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{consoleundhud}
\caption{UT99 HUD with Chat Diamond console}
\label{fig:chatdiamond_console_hud}
\end{figure}

Please note that Chat Diamond's console is not much different from default UT99, visually.  The changes are how Chat Diamond interprets the raw messages thrown and utilize them in a constructive way. So this is where magic \href{https://github.com/ravimohan1991/ChatDiamond/blob/859323fbd80266b21c9dab163b067cacfa318463/Classes/CDUTConsole.uc#L52-L71}{code} comes in.  In order to understand that let me first demonstrate UT messaging by a table\footnote{\label{foot:hudconsolediff} The ``messages'' for instance: `plushie was smaked down by Mental\_Instituitions's Rocket Launcher', are actually strings which can be seen in the line 117 of the \href{http://uncodex.ut-files.com/UT/v436/Source_botpack/deathmessageplus.html}{code}.  This also shows how some deathmessages can be suppressed in the console thus differing from HUD.}.

The mapping to relevant arguments is like so in Table \ref{tab:messageform}.


The tables need to be explained and pondered.

\section{Native Coding}
Chat Diamond is a native mod, meaning, a program invoking C++ functions.  At the time of writing, minor usage of the library 
\href{https://en.cppreference.com/w/cpp/regex}{regular expressions} is evident by the following \href{https://github.com/ravimohan1991/ChatDiamond/blob/6e3b684403fb75811c1cde6372c9125370bc796a/Classes/CDDiscordActor.uc#L61}{code}

\begin{lstlisting}[frame=single]
native final static function string SpitIpFromChatString(string Message, out int ICategory);
\end{lstlisting}

To understand the implementation of the above unrealscript function, please see the \href{https://github.com/ravimohan1991/ChatDiamond/blob/6e3b684403fb75811c1cde6372c9125370bc796a/UTNativeEssentials/ChatDiamond/Src/ChatDiamondNative.cpp#L52}{code} displayed as follows

\lstset{language=C++}
\begin{lstlisting}[frame=single]
void ACDDiscordActor::execSpitIpFromChatString(FFrame& Stack, RESULT_DECL)
{
	guard(ACDDiscordActor::execSpitIpFromChatString);
	P_GET_STR(Message);
	P_GET_INT_REF(IPCategory);
	P_FINISH;

	std::smatch Match;

	// The nice way out, from game and web server mix, seems to make an assumption that, in context of UT, the gameserver IP
	// be given by complete port number.

	// https://github.com/ravimohan1991/ChatDiamond/issues/1#issuecomment-1356906185
	std::regex GameIPMould("\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\:\\d{1,4}");
	std::regex WebIPMould("\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}");

	std::wstring WString(*Message);
	std::string SampleString(WString.begin(), WString.end());

	std::string IPString;

	// Look for game IP
	if (std::regex_search(SampleString, Match, GameIPMould))
	{
		for (auto Tempo : Match)
		{
			IPString = Tempo.str();
			break;
		}
	}

	if (!IPString.empty())
	{
		std::wstring WideIPString = std::wstring(IPString.begin(), IPString.end());
		*IPCategory = 0;
		*(FString*)Result = WideIPString.c_str();
		return;
	}

	// Look for game IP
	if (std::regex_search(SampleString, Match, WebIPMould))
	{
		for (auto Tempo : Match)
		{
			IPString = Tempo.str();
			break;
		}
	}

	if (!IPString.empty())
	{
		std::wstring WideIPString = std::wstring(IPString.begin(), IPString.end());
		*IPCategory = 1;
		*(FString*)Result = WideIPString.c_str();
		return;
	}

	std::wstring WideIPString = std::wstring(IPString.begin(), IPString.end());
	*IPCategory = 2;
	*(FString*)Result = WideIPString.c_str();

	unguard;
}
\end{lstlisting}

There are few remarks
\begin{itemize}
\item The C++ code isn't the ordinary one.  That is punctuated with variety of macros, which generate, what I would like to call, the
first hints of reflection system.
\item In order to linearize the story of native coding and start producing practical code, we need to first learn few ``game-dev'' terminologies
and practices.
\end{itemize}

\subsection{Why Native Code?}
Unrealscript is a highly managed language which comes with limitations, which is characteristic of any managed language actually, such as slow(er) 
runtime (when compared with C++), ability to fuse with well defined C++ applications (like Discord), and lack of programmers' choice or taste.  Don't get
me wrong, the language is best for what it does, scripting mods for the game.  Since this is 2020 decade, along with native support, there is no 2000's environment 
limitation, especially with the new community patches.

\subsection{Build System}
I have been using combination of Wot Greal (unrealscript code) and Microsoft Visual Studio 2022 (C++ code) IDEs for developing Chat Diamond.  
Therefore I have organized the repository with the conforming hierarchical structure.
\begin{figure}
\begin{forest}
  for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    calign=first,
    edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
    },
    before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
    fit=band,
    before computing xy={l=15pt},
  }
[UnrealTournament
  [ChatDiamond (repository)
    [Classes]
    [Sounds]
    [Textures]
    [UTNativeEssentials
        [ChatDiamond
            [Inc(C++)]
            [Src(C++)]
        ]
        [Core]
        [Engine]
        [CamkeLists.txt]
        [GenerateProjectFiles.bat]
    ]
  ]
  [System
    [UnrealTournament.exe]
    [UCC.exe]
  ]
]
\end{forest}
\caption{Chat Diamond project hierarchy.}
\label{forest:project_hierar}
\end{figure}

What we have achieved by doing so is a reconcoliation of UT99's unrealscript modding environemnt with C++ dev environment yielding a schematic version controlled framework (a Github 
\href{https://github.com/ravimohan1991/ChatDiamond}{repository}).  
All the C++ code goes to the folders marked with, well, C++ and unrealscript code goes to top level \FolderColor{ChatDiamond \textbackslash Classes} directory.  

The \FolderColor{Core} is the directory containing ``header-only'' library elements, meaning .h files and the already compiled binary \FileColor{Core.lib}.  Few remarks are to be worded
\begin{itemize}
\item Such libraries, which are prebuilt and whose implementation is hidden with only headers (the API) visible, are known as ``\texttt{Interface}'' libraries in CMake's scope.  \FolderColor{Engine} is another example of directory containing such \texttt{Interface} library.  
Also both of the \FolderColor{Engine} and \FolderColor{Core} directories contain the directories \FolderColor{Inc}, \FolderColor{Src}, and \FolderColor{Lib} sub directories. 
\item From research, \FileColor{Core.lib} and \FileColor{Engine.lib}, which are static libraries, seem to be the ``basic necessicities'' for linking with a native mod. 
\item In the hierarchy, I am only showing the top level \FileColor{CmakeLists.txt}.  If you are familiar with the build utility, you can comprehend the presence of one each inside \FolderColor{ChatDiamond}, \FolderColor{Core}, and \FolderColor{Engine} directories.
\item Currently, I am developing on and for Windows (should be evident from \FileColor{GenerateProjectFiles.bat}).  It goes against my philosophy of cross-platform development\footnote{For solid enough work please see \href{https://github.com/ravimohan1991/KarmaEngine}{Karma}.} given the 32-bit jugaad for Linux libraries, I may do something in future.  MacOS seems like a workable goal since I own a MacBook Pro.
\end{itemize}  

Make sure that your machine has \href{https://cmake.org/}{CMake} installed.  For uninitiated programmers (in my POV read premakers), let me
supply a crash course on CMake, for our purposes here.

\subsubsection{UT and CMake}
In a C++, or any good programming language, there is a proper toolchain which pipes the human written code to turing machine understantable arrangement of bits 
(zeroes and ones).  This usually involves lot of garbage intermediatory files which most of the part are useless, unless you suddenly, out of the blue, decide to do 
scavanging some day.

The responsibility of a good build system is to understand such redundancies and provide a manageable way of dealing with chunks of huge memory files.
Let me demonstrate by simple logistics.  

At the time, the ChatDiamond C++ component has about three to four MB worth of code files (.h and .cpp).  
Visual Studio 2022 generates a solution build of about 144 MB worth of memory and the output is \FileColor{ChatDiamond.dll} which is about two MB.  The intermediatory files are 
for IDE's (Visual Studio for instance) and compiler (MSVC or Clang) use only and therefore should be dealt separately by a decent build system\footnote{Actually this is the
reinforcement of the concept of Universal Turing Machine.  That a good compiler should be able to generate same set of instructions, i.e. a program, 
which should bahave that same way, no matter a laptop or desktop or smart phone.  Please see \href{https://en.wikipedia.org/wiki/Von_Neumann_architecture}{von-Neumann architecture} for a lucid connection 
between Universal Turing Machine conept and PCs or Macbooks.}.

Given the variety of compilers, with even more variety of platforms, CMake is the most suitable build system and friend that a programmer can, well, make and use.  Along with the clear 
distinct folder generation for intermediate files, CMake comes with high degree of configurability, required for build, and compatibility with known compilers\footnote{For a comprehensive list, please visit .\href{https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html}{here}}.  
CMake supports the Windows, Unix, and Linux based platforms.

UT99 was officially released and supported on multiple platforms.  The community clearly intendes on keeping that flame intact.  Therefore a rocket scientis isn't really needed to gauge the obvious link 
between UT and CMake.

With enough convincing we are now in a position to understand the organization of this project (or some UT project organization, in general).  This may serve as a template.  
Consider the hierarcy \ref{forest:project_hierar}.  Then the \href{https://github.com/ravimohan1991/ChatDiamond/blob/f7950b2591b93a54600459ec58d7ddf57fe9218d/UTNativeEssentials/CMakeLists.txt#L201-L216}{code} becomes relevant as follows

\lstset{language=[5.0]Lua}
\begin{lstlisting}[frame=single]
###################
# Link Directories
###################
link_directories(ChatDiamond Core/Lib Engine/Lib)

###########################################
# Target Definitions / Custom Modding Stuff
###########################################
add_subdirectory(ChatDiamond)
target_include_directories(ChatDiamond
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/Core/Inc
    ${CMAKE_CURRENT_SOURCE_DIR}/Engine/Inc)


######################
# Target Linking Rules
######################
target_link_libraries(ChatDiamond PUBLIC Core Engine)
\end{lstlisting}

In line 4, we are telling CMake to generate relevant project files (for MSVC or QTCreator) such that the linking be done with the libraries stored in the \FolderColor{Core\textbackslash Lib} and \FolderColor{Engine\textbackslash Lib} directories\footnote{Note that directories are relative to the current CMake operation direcotry which is basically the location of the \FileColor{CMakeLists.txt} with above code.}.

Next from line 9 to 13, we intend to tell CMake to add the native mod project, specified by \FileColor{CMakeLists.txt} present in subdirectory \FolderColor{ChatDiamond}.

Next we proceed towards the file mentioned in previous paragraph (taking a level deep plunge in the folder hierarchy).  The \href{https://github.com/ravimohan1991/ChatDiamond/blob/f7950b2591b93a54600459ec58d7ddf57fe9218d/UTNativeEssentials/ChatDiamond/CMakeLists.txt}{code} is
\lstset{language=[5.0]Lua}
\begin{lstlisting}[frame=single]
cmake_minimum_required(VERSION 3.0.0)

project(ChatDiamond)

file(GLOB CD_HEADERS Inc/*.h)

add_library(ChatDiamond SHARED Src/ChatDiamondNative.cpp ${CD_HEADERS})

target_include_directories(ChatDiamond
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/Inc
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/Inc>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

target_compile_definitions(ChatDiamond PUBLIC ChatDiamond)
\end{lstlisting}

Line 3 declares the mod project name.  Then we specify all the .h files by collectively assembling them with the command \texttt{file} and labelling them \emph{CD\_HEADERS}.  Then we specify the library name via \texttt{add\_library} command in the first field, followed by the type (\texttt{SHARED} means dynamic library) followed by all the source (.cpp) files.  Then we mention headers so that they may appear nicely in the project.  For instance, in XCode the project ChatDiamond looks like
\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{chatdiamond_xcode}
\caption{A ChatDiamond XCode project.}
\label{fig:chatdiamond_xcode}
\end{figure}

furthermore we apprise the CMake that the target, ChatDiamond library, needs the includes of \FolderColor{Inc} and provides the same folder as API for various libraries to untilize the functionality.  Finally we set the public usable name, which is same, of the library.

Now we come back to the topmost \FileColor{CMakeLists.txt}, line 10, which can be regarded the continuation of \texttt{target\_include\_directories} of the previous one.  Here we want to tell CMake to include the library directories (the basic essentials) \FolderColor{Core\textbackslash Inc} and \FolderColor{Engine\textbackslash Inc} in our ChatDiamond project and in line 19 we apprise CMake to link those libraries thus generating the wholesome \FileColor{ChatDiamond.dll}, if we are on Windows\footnote{On Linux based OS, the dynamic library has the extension of ``.so'', which stands for ``shared object''.}.

\subsubsection{C++ for UT}
We are basically in the territory of interface between unrealsccript and C++ for the game UT99.  Remember the C++ standard that the UT99 was written in could have been C98 (or SO/IEC 14882:1998) and unrealscript could have had influences.

In 2022, we can be using any standard ranging from C++11 to C++20.  In CMake above, we defined the standard like \href{https://github.com/ravimohan1991/ChatDiamond/blob/f7950b2591b93a54600459ec58d7ddf57fe9218d/UTNativeEssentials/CMakeLists.txt#L11}{so}
\lstset{language=[5.0]Lua}
\begin{lstlisting}[frame=single]
set(CMAKE_CXX_STANDARD 11)
\end{lstlisting}
This is what we mean by ``modern'', the ability to take good parts from the standards in history of C++ evolution.  Whith this modern approach, we can leverage the latest  XCode or Microsoft's Visual Studio features (including smarter intellisense) and produce the code that can and will work in future.

\appendix

\section{Messaging Tables}

\begin{tabcontainer}
 \begin{tabularx}{\textwidth}{| X | X | X | X |}
 \hline
 \makecell{Console\\ Owner\\ State} & \makecell{Death\\ Messages}\footnote{A string rather.  See \ref{foot:hudconsolediff}}  & \makecell{Server\\ Announcements\footnote{Server adds?}} & \makecell{Talk \\ TeamTalk} \\ [0.5ex] 
 \hline\hline
 
\makecell{Multiplayer \\Spectator} & \makecell{\color{red}{plushie was}\\ \color{red}{smaked down}\\ \color{red}{by MI's}\\ \color{red}{Rocket Launcher}} & \makecell{Type !cg to\\ visit combogib\\ grapple server}  & \makecell{A: Self Sent- \\RN\footnote{Receiever's (who is spectator) Name}:Hola\\  \\ B. By Player-\\ RN:SN\footnote{Sender's name, who is a player.}:Hola \\ \\ C. By spectator\footnote{A different spectator}\\ SN:Hola}\\

\hline
  \end{tabularx}
  \caption{Table of Messages.}
  \label{tab:messform}
\end{tabcontainer}

\begin{tabcontainer}
 \begin{tabularx}{\textwidth}{| X | X | X | X |}
 \hline
 \makecell{Console\\ Owner\\ State} & \makecell{Death\\ Messages}\footnote{A string rather.  See \ref{foot:hudconsolediff}}  & \makecell{Server\\ Announcements\footnote{Server adds?}} & \makecell{Talk \\ TeamTalk} \\ [0.5ex] 
 \hline\hline
 
\makecell{Multiplayer \\Spectator} & \makecell{MessageType:  \\ DeathMessage?\\ \\ PRI:  Local?} & \makecell{MessageType:\\ Event \\  \\ PRI: Local}  & \makecell{A. \\ MessageType:\\ Event  \\ PRI: Local \\ \\  B.\\ MessageType: \\ Event \\ PRI: local\\ \\ C. \\  MessageType: \\ Event \\ PRI: Local}\\
    \hline

\makecell{Multiplayer\\ Player} & \makecell{Message Type: \\ Event \\ PRI: Local? } & \makecell{Message Type: \\ Event \\ PRI: None} & \makecell{A. \\ MessageType: \\ Say\\ PRI: Local\\ \\ B. \\ MessageType: \\ Say \\ PRI: SenderPRI \\ \\ C. \\ MessageType: \\ ? \\ PRI: ?}\\
    \hline
  \end{tabularx}
  \caption{Table of argument types.}
  \label{tab:messageform}
\end{tabcontainer}

\end{document}